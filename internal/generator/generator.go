package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/stuckinforloop/oak/internal/config"
	"github.com/stuckinforloop/oak/internal/parser"
	"github.com/stuckinforloop/oak/internal/types"
)

// GenerationResult represents the result of code generation
type GenerationResult struct {
	PackageName string // Name of the package
	FilePath    string // Path where the generated file should be written
	Content     string // Generated Go code content
}

// Generator handles code generation for LogValue methods
type Generator struct {
	config       *config.Config
	typeAnalyzer *types.TypeAnalyzer
	template     *template.Template
}

// New creates a new Generator instance
func New(cfg *config.Config) *Generator {
	analyzer := types.NewTypeAnalyzer(cfg)

	gen := &Generator{
		config:       cfg,
		typeAnalyzer: analyzer,
	}

	// Parse the template
	tmpl, err := template.New("logvalue").Funcs(gen.templateFuncs()).Parse(logValueTemplate)
	if err != nil {
		panic(fmt.Sprintf("Failed to parse template: %v", err))
	}
	gen.template = tmpl

	return gen
}

// GenerateForStructs generates LogValue methods for a list of structs
func (g *Generator) GenerateForStructs(structs []parser.StructInfo) (*GenerationResult, error) {
	if len(structs) == 0 {
		return nil, fmt.Errorf("no structs provided for generation")
	}

	// All structs should be from the same package
	packageName := structs[0].PackageName
	packageDir := filepath.Dir(structs[0].FilePath)

	// Filter structs that have loggable fields
	var validStructs []StructTemplateData
	for _, structInfo := range structs {
		if g.typeAnalyzer.HasLoggableFields(structInfo) {
			templateData := g.prepareStructData(structInfo)
			validStructs = append(validStructs, templateData)
		}
	}

	if len(validStructs) == 0 {
		return nil, fmt.Errorf("no structs with loggable fields found")
	}

	// Prepare template data
	data := TemplateData{
		PackageName: packageName,
		Structs:     validStructs,
	}

	// Generate code
	var buf bytes.Buffer
	if err := g.template.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w", err)
	}

	// Determine output file path
	outputFile := filepath.Join(packageDir, packageName+"_logvalue.go")

	result := &GenerationResult{
		PackageName: packageName,
		FilePath:    outputFile,
		Content:     string(formatted),
	}

	return result, nil
}

// prepareStructData prepares template data for a single struct
func (g *Generator) prepareStructData(structInfo parser.StructInfo) StructTemplateData {
	analyses := g.typeAnalyzer.AnalyzeStruct(structInfo)

	// Generate receiver name (first letter of struct name, lowercase)
	receiverName := strings.ToLower(string(structInfo.Name[0]))

	var fields []FieldTemplateData
	for _, analysis := range analyses {
		if analysis.Action == types.ActionSkip {
			continue // Skip fields marked with log:"-"
		}

		fieldData := FieldTemplateData{
			Name:         analysis.Field.Name,
			LogStatement: g.typeAnalyzer.GenerateLogStatement(analysis, receiverName),
		}
		fields = append(fields, fieldData)
	}

	return StructTemplateData{
		Name:         structInfo.Name,
		ReceiverName: receiverName,
		Fields:       fields,
	}
}

// templateFuncs returns template functions for use in the template
func (g *Generator) templateFuncs() template.FuncMap {
	return template.FuncMap{
		"join": strings.Join,
	}
}

// TemplateData represents data passed to the template
type TemplateData struct {
	PackageName string
	Structs     []StructTemplateData
}

// StructTemplateData represents data for a single struct
type StructTemplateData struct {
	Name         string
	ReceiverName string
	Fields       []FieldTemplateData
}

// FieldTemplateData represents data for a single field
type FieldTemplateData struct {
	Name         string
	LogStatement string
}

// logValueTemplate is the Go template for generating LogValue methods
const logValueTemplate = `// Code generated by oak. DO NOT EDIT.
package {{.PackageName}}

import "log/slog"

{{range .Structs}}
// LogValue implements slog.LogValuer for {{.Name}}
func ({{.ReceiverName}} {{.Name}}) LogValue() slog.Value {
	return slog.GroupValue(
		{{range $i, $field := .Fields}}{{if $i}},
		{{end}}{{$field.LogStatement}}{{end}},
	)
}
{{end}}`
