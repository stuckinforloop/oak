package generator

import (
	"strings"
	"testing"

	"github.com/stuckinforloop/oak/internal/config"
	"github.com/stuckinforloop/oak/internal/parser"
)

func TestGenerateForStructs(t *testing.T) {
	cfg := &config.Config{
		RedactKeys:    []string{"password"},
		RedactMessage: "[REDACTED]",
	}
	generator := New(cfg)

	structs := []parser.StructInfo{
		{
			Name:        "User",
			PackageName: "main",
			FilePath:    "/tmp/main.go",
			Fields: []parser.FieldInfo{
				{Name: "ID", Type: "int"},
				{Name: "Username", Type: "string"},
				{Name: "Password", Type: "string"},
				{Name: "Notes", Type: "string", LogTag: "-"},
			},
		},
	}

	result, err := generator.GenerateForStructs(structs)
	if err != nil {
		t.Fatalf("GenerateForStructs failed: %v", err)
	}

	if result.PackageName != "main" {
		t.Errorf("Expected package name 'main', got %s", result.PackageName)
	}

	if !strings.HasSuffix(result.FilePath, "main_logvalue.go") {
		t.Errorf("Expected file path to end with 'main_logvalue.go', got %s", result.FilePath)
	}

	// Check that the generated code contains expected elements
	expectedElements := []string{
		"// Code generated by oak. DO NOT EDIT.",
		"package main",
		"import \"log/slog\"",
		"func (u User) LogValue() slog.Value",
		"slog.GroupValue(",
		"slog.Int64(\"ID\", int64(u.ID))",
		"slog.String(\"Username\", u.Username)",
		"slog.String(\"Password\", \"[REDACTED]\")",
	}

	for _, expected := range expectedElements {
		if !strings.Contains(result.Content, expected) {
			t.Errorf("Generated code missing expected element: %s", expected)
		}
	}

	// Check that Notes field is not included (log:"-")
	if strings.Contains(result.Content, "Notes") {
		t.Errorf("Generated code should not contain Notes field (marked with log:\"-\")")
	}
}

func TestGenerateForStructsWithMultipleStructs(t *testing.T) {
	cfg := config.DefaultConfig()
	generator := New(cfg)

	structs := []parser.StructInfo{
		{
			Name:        "User",
			PackageName: "models",
			FilePath:    "/tmp/models/user.go",
			Fields: []parser.FieldInfo{
				{Name: "ID", Type: "int"},
				{Name: "Name", Type: "string"},
			},
		},
		{
			Name:        "Product",
			PackageName: "models",
			FilePath:    "/tmp/models/product.go",
			Fields: []parser.FieldInfo{
				{Name: "ID", Type: "int"},
				{Name: "Title", Type: "string"},
				{Name: "Price", Type: "float64"},
			},
		},
	}

	result, err := generator.GenerateForStructs(structs)
	if err != nil {
		t.Fatalf("GenerateForStructs failed: %v", err)
	}

	// Check that both structs are included
	if !strings.Contains(result.Content, "func (u User) LogValue()") {
		t.Errorf("Generated code missing User LogValue method")
	}

	if !strings.Contains(result.Content, "func (p Product) LogValue()") {
		t.Errorf("Generated code missing Product LogValue method")
	}

	// Check field types
	expectedElements := []string{
		"slog.Int64(\"ID\", int64(u.ID))",
		"slog.String(\"Name\", u.Name)",
		"slog.Int64(\"ID\", int64(p.ID))",
		"slog.String(\"Title\", p.Title)",
		"slog.Float64(\"Price\", p.Price)",
	}

	for _, expected := range expectedElements {
		if !strings.Contains(result.Content, expected) {
			t.Errorf("Generated code missing expected element: %s", expected)
		}
	}
}

func TestGenerateForStructsNoLoggableFields(t *testing.T) {
	cfg := config.DefaultConfig()
	generator := New(cfg)

	structs := []parser.StructInfo{
		{
			Name:        "Empty",
			PackageName: "main",
			FilePath:    "/tmp/main.go",
			Fields: []parser.FieldInfo{
				{Name: "Field1", Type: "string", LogTag: "-"},
				{Name: "Field2", Type: "int", LogTag: "-"},
			},
		},
	}

	_, err := generator.GenerateForStructs(structs)
	if err == nil {
		t.Errorf("Expected error for struct with no loggable fields")
	}

	expectedError := "no structs with loggable fields found"
	if !strings.Contains(err.Error(), expectedError) {
		t.Errorf("Expected error to contain %q, got %q", expectedError, err.Error())
	}
}

func TestGenerateForStructsEmpty(t *testing.T) {
	cfg := config.DefaultConfig()
	generator := New(cfg)

	_, err := generator.GenerateForStructs([]parser.StructInfo{})
	if err == nil {
		t.Errorf("Expected error for empty structs list")
	}

	expectedError := "no structs provided for generation"
	if !strings.Contains(err.Error(), expectedError) {
		t.Errorf("Expected error to contain %q, got %q", expectedError, err.Error())
	}
}

func TestPrepareStructData(t *testing.T) {
	cfg := &config.Config{
		RedactKeys:    []string{"secret"},
		RedactMessage: "[HIDDEN]",
	}
	generator := New(cfg)

	structInfo := parser.StructInfo{
		Name: "TestStruct",
		Fields: []parser.FieldInfo{
			{Name: "ID", Type: "int"},
			{Name: "Name", Type: "string"},
			{Name: "Secret", Type: "string"},
			{Name: "Notes", Type: "string", LogTag: "-"},
		},
	}

	result := generator.prepareStructData(structInfo)

	if result.Name != "TestStruct" {
		t.Errorf("Expected struct name 'TestStruct', got %s", result.Name)
	}

	if result.ReceiverName != "t" {
		t.Errorf("Expected receiver name 't', got %s", result.ReceiverName)
	}

	// Should have 3 fields (Notes is skipped)
	if len(result.Fields) != 3 {
		t.Errorf("Expected 3 fields, got %d", len(result.Fields))
	}

	// Check field names
	expectedFields := []string{"ID", "Name", "Secret"}
	for i, expected := range expectedFields {
		if i >= len(result.Fields) {
			t.Errorf("Missing field %s", expected)
			continue
		}
		if result.Fields[i].Name != expected {
			t.Errorf("Field %d: expected name %s, got %s", i, expected, result.Fields[i].Name)
		}
	}

	// Check that Secret field is redacted
	secretField := result.Fields[2]
	if !strings.Contains(secretField.LogStatement, "[HIDDEN]") {
		t.Errorf("Secret field should be redacted, got: %s", secretField.LogStatement)
	}
}

func TestReceiverNameGeneration(t *testing.T) {
	cfg := config.DefaultConfig()
	generator := New(cfg)

	testCases := []struct {
		structName   string
		expectedName string
	}{
		{"User", "u"},
		{"Product", "p"},
		{"APIKey", "a"},
		{"HTTPClient", "h"},
	}

	for _, tc := range testCases {
		structInfo := parser.StructInfo{
			Name: tc.structName,
			Fields: []parser.FieldInfo{
				{Name: "ID", Type: "int"},
			},
		}

		result := generator.prepareStructData(structInfo)
		if result.ReceiverName != tc.expectedName {
			t.Errorf("Struct %s: expected receiver name %s, got %s",
				tc.structName, tc.expectedName, result.ReceiverName)
		}
	}
}
