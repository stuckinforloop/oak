package writer

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/stuckinforloop/oak/internal/generator"
)

// Writer handles writing generated code to files
type Writer struct {
	// Add any configuration if needed in the future
}

// New creates a new Writer instance
func New() *Writer {
	return &Writer{}
}

// WriteResult writes a GenerationResult to the filesystem
func (w *Writer) WriteResult(result *generator.GenerationResult) error {
	if result == nil {
		return fmt.Errorf("generation result is nil")
	}

	// Ensure the directory exists
	dir := filepath.Dir(result.FilePath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	// Check if file already exists and warn about overwriting
	if _, err := os.Stat(result.FilePath); err == nil {
		// File exists, we'll overwrite it (this is expected behavior for generated files)
		fmt.Printf("Overwriting existing file: %s\n", result.FilePath)
	}

	// Write the generated content to the file
	if err := os.WriteFile(result.FilePath, []byte(result.Content), 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %w", result.FilePath, err)
	}

	fmt.Printf("Generated: %s\n", result.FilePath)
	return nil
}

// WriteResults writes multiple GenerationResults to the filesystem
func (w *Writer) WriteResults(results []*generator.GenerationResult) error {
	if len(results) == 0 {
		return fmt.Errorf("no results to write")
	}

	var errors []error
	successCount := 0

	for _, result := range results {
		if err := w.WriteResult(result); err != nil {
			errors = append(errors, err)
		} else {
			successCount++
		}
	}

	if len(errors) > 0 {
		// Return the first error, but log all errors
		for i, err := range errors {
			if i == 0 {
				fmt.Printf("Error: %v\n", err)
			} else {
				fmt.Printf("Additional error: %v\n", err)
			}
		}
		return fmt.Errorf("failed to write %d out of %d files", len(errors), len(results))
	}

	fmt.Printf("Successfully generated %d file(s)\n", successCount)
	return nil
}

// ValidateOutputPath validates that the output path is writable
func (w *Writer) ValidateOutputPath(filePath string) error {
	dir := filepath.Dir(filePath)

	// Check if directory exists or can be created
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("cannot create directory %s: %w", dir, err)
	}

	// Check if we can write to the directory
	testFile := filepath.Join(dir, ".oak_write_test")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		return fmt.Errorf("cannot write to directory %s: %w", dir, err)
	}

	// Clean up test file
	os.Remove(testFile)

	return nil
}

// BackupExistingFile creates a backup of an existing file before overwriting
func (w *Writer) BackupExistingFile(filePath string) error {
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		// File doesn't exist, no backup needed
		return nil
	}

	backupPath := filePath + ".bak"

	// Read the existing file
	content, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read existing file %s: %w", filePath, err)
	}

	// Write backup
	if err := os.WriteFile(backupPath, content, 0644); err != nil {
		return fmt.Errorf("failed to create backup %s: %w", backupPath, err)
	}

	fmt.Printf("Created backup: %s\n", backupPath)
	return nil
}

// CleanupBackups removes backup files created by BackupExistingFile
func (w *Writer) CleanupBackups(filePaths []string) error {
	for _, filePath := range filePaths {
		backupPath := filePath + ".bak"
		if _, err := os.Stat(backupPath); err == nil {
			if err := os.Remove(backupPath); err != nil {
				fmt.Printf("Warning: failed to remove backup file %s: %v\n", backupPath, err)
			}
		}
	}
	return nil
}

// GetOutputFileName generates the output filename for a given package
func GetOutputFileName(packageName string) string {
	return packageName + "_logvalue.go"
}

// IsGeneratedFile checks if a file appears to be generated by Oak
func IsGeneratedFile(filePath string) (bool, error) {
	content, err := os.ReadFile(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, err
	}

	// Check for Oak's generation marker
	contentStr := string(content)
	marker := "// Code generated by oak. DO NOT EDIT."

	return len(contentStr) >= len(marker) && contentStr[:len(marker)] == marker, nil
}
