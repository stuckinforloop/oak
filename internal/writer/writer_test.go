package writer

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stuckinforloop/oak/internal/generator"
)

func TestWriteResult(t *testing.T) {
	writer := New()
	tempDir := t.TempDir()

	result := &generator.GenerationResult{
		PackageName: "test",
		FilePath:    filepath.Join(tempDir, "test_logvalue.go"),
		Content:     "// Code generated by oak. DO NOT EDIT.\npackage test\n",
	}

	err := writer.WriteResult(result)
	if err != nil {
		t.Fatalf("WriteResult failed: %v", err)
	}

	// Check that file was created
	if _, err := os.Stat(result.FilePath); os.IsNotExist(err) {
		t.Errorf("File was not created: %s", result.FilePath)
	}

	// Check file content
	content, err := os.ReadFile(result.FilePath)
	if err != nil {
		t.Fatalf("Failed to read generated file: %v", err)
	}

	if string(content) != result.Content {
		t.Errorf("File content mismatch.\nExpected: %s\nGot: %s", result.Content, string(content))
	}
}

func TestWriteResultNil(t *testing.T) {
	writer := New()

	err := writer.WriteResult(nil)
	if err == nil {
		t.Errorf("Expected error for nil result")
	}

	expectedError := "generation result is nil"
	if !strings.Contains(err.Error(), expectedError) {
		t.Errorf("Expected error to contain %q, got %q", expectedError, err.Error())
	}
}

func TestWriteResults(t *testing.T) {
	writer := New()
	tempDir := t.TempDir()

	results := []*generator.GenerationResult{
		{
			PackageName: "pkg1",
			FilePath:    filepath.Join(tempDir, "pkg1_logvalue.go"),
			Content:     "// Code generated by oak. DO NOT EDIT.\npackage pkg1\n",
		},
		{
			PackageName: "pkg2",
			FilePath:    filepath.Join(tempDir, "pkg2_logvalue.go"),
			Content:     "// Code generated by oak. DO NOT EDIT.\npackage pkg2\n",
		},
	}

	err := writer.WriteResults(results)
	if err != nil {
		t.Fatalf("WriteResults failed: %v", err)
	}

	// Check that both files were created
	for _, result := range results {
		if _, err := os.Stat(result.FilePath); os.IsNotExist(err) {
			t.Errorf("File was not created: %s", result.FilePath)
		}
	}
}

func TestWriteResultsEmpty(t *testing.T) {
	writer := New()

	err := writer.WriteResults([]*generator.GenerationResult{})
	if err == nil {
		t.Errorf("Expected error for empty results")
	}

	expectedError := "no results to write"
	if !strings.Contains(err.Error(), expectedError) {
		t.Errorf("Expected error to contain %q, got %q", expectedError, err.Error())
	}
}

func TestValidateOutputPath(t *testing.T) {
	writer := New()
	tempDir := t.TempDir()

	// Test valid path
	validPath := filepath.Join(tempDir, "subdir", "test.go")
	err := writer.ValidateOutputPath(validPath)
	if err != nil {
		t.Errorf("ValidateOutputPath failed for valid path: %v", err)
	}

	// Check that directory was created
	dir := filepath.Dir(validPath)
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		t.Errorf("Directory was not created: %s", dir)
	}
}

func TestBackupExistingFile(t *testing.T) {
	writer := New()
	tempDir := t.TempDir()

	// Create an existing file
	existingFile := filepath.Join(tempDir, "existing.go")
	originalContent := "original content"
	err := os.WriteFile(existingFile, []byte(originalContent), 0644)
	if err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Create backup
	err = writer.BackupExistingFile(existingFile)
	if err != nil {
		t.Fatalf("BackupExistingFile failed: %v", err)
	}

	// Check that backup was created
	backupFile := existingFile + ".bak"
	if _, err := os.Stat(backupFile); os.IsNotExist(err) {
		t.Errorf("Backup file was not created: %s", backupFile)
	}

	// Check backup content
	backupContent, err := os.ReadFile(backupFile)
	if err != nil {
		t.Fatalf("Failed to read backup file: %v", err)
	}

	if string(backupContent) != originalContent {
		t.Errorf("Backup content mismatch.\nExpected: %s\nGot: %s", originalContent, string(backupContent))
	}
}

func TestBackupNonExistentFile(t *testing.T) {
	writer := New()
	tempDir := t.TempDir()

	nonExistentFile := filepath.Join(tempDir, "nonexistent.go")
	err := writer.BackupExistingFile(nonExistentFile)
	if err != nil {
		t.Errorf("BackupExistingFile should not fail for non-existent file: %v", err)
	}

	// Check that no backup was created
	backupFile := nonExistentFile + ".bak"
	if _, err := os.Stat(backupFile); !os.IsNotExist(err) {
		t.Errorf("Backup file should not exist for non-existent original file")
	}
}

func TestCleanupBackups(t *testing.T) {
	writer := New()
	tempDir := t.TempDir()

	// Create some backup files
	files := []string{
		filepath.Join(tempDir, "file1.go"),
		filepath.Join(tempDir, "file2.go"),
	}

	for _, file := range files {
		backupFile := file + ".bak"
		err := os.WriteFile(backupFile, []byte("backup content"), 0644)
		if err != nil {
			t.Fatalf("Failed to create backup file: %v", err)
		}
	}

	// Cleanup backups
	err := writer.CleanupBackups(files)
	if err != nil {
		t.Errorf("CleanupBackups failed: %v", err)
	}

	// Check that backup files were removed
	for _, file := range files {
		backupFile := file + ".bak"
		if _, err := os.Stat(backupFile); !os.IsNotExist(err) {
			t.Errorf("Backup file should have been removed: %s", backupFile)
		}
	}
}

func TestGetOutputFileName(t *testing.T) {
	testCases := []struct {
		packageName string
		expected    string
	}{
		{"main", "main_logvalue.go"},
		{"booking", "booking_logvalue.go"},
		{"user_service", "user_service_logvalue.go"},
	}

	for _, tc := range testCases {
		result := GetOutputFileName(tc.packageName)
		if result != tc.expected {
			t.Errorf("GetOutputFileName(%s) = %s, expected %s", tc.packageName, result, tc.expected)
		}
	}
}

func TestIsGeneratedFile(t *testing.T) {
	tempDir := t.TempDir()

	// Create a generated file
	generatedFile := filepath.Join(tempDir, "generated.go")
	generatedContent := "// Code generated by oak. DO NOT EDIT.\npackage test\n"
	err := os.WriteFile(generatedFile, []byte(generatedContent), 0644)
	if err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Create a non-generated file
	normalFile := filepath.Join(tempDir, "normal.go")
	normalContent := "package test\n\ntype User struct {}\n"
	err = os.WriteFile(normalFile, []byte(normalContent), 0644)
	if err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Test generated file
	isGenerated, err := IsGeneratedFile(generatedFile)
	if err != nil {
		t.Errorf("IsGeneratedFile failed: %v", err)
	}
	if !isGenerated {
		t.Errorf("Expected generated file to be detected as generated")
	}

	// Test normal file
	isGenerated, err = IsGeneratedFile(normalFile)
	if err != nil {
		t.Errorf("IsGeneratedFile failed: %v", err)
	}
	if isGenerated {
		t.Errorf("Expected normal file to not be detected as generated")
	}

	// Test non-existent file
	nonExistentFile := filepath.Join(tempDir, "nonexistent.go")
	isGenerated, err = IsGeneratedFile(nonExistentFile)
	if err != nil {
		t.Errorf("IsGeneratedFile should not fail for non-existent file: %v", err)
	}
	if isGenerated {
		t.Errorf("Expected non-existent file to not be detected as generated")
	}
}
