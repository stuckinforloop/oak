package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stuckinforloop/oak/internal/parser"
)

func TestRunHelp(t *testing.T) {
	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err := run([]string{"--help"})

	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Errorf("run with --help should not return error: %v", err)
	}

	// Read captured output
	buf := make([]byte, 1024)
	n, _ := r.Read(buf)
	output := string(buf[:n])

	if !strings.Contains(output, "oak v0.0.1") {
		t.Errorf("Help output should contain version")
	}

	if !strings.Contains(output, "USAGE:") {
		t.Errorf("Help output should contain usage information")
	}
}

func TestRunVersion(t *testing.T) {
	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err := run([]string{"--version"})

	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Errorf("run with --version should not return error: %v", err)
	}

	// Read captured output
	buf := make([]byte, 1024)
	n, _ := r.Read(buf)
	output := string(buf[:n])

	expected := "oak v0.0.1"
	if !strings.Contains(output, expected) {
		t.Errorf("Version output should contain %q, got %q", expected, output)
	}
}

func TestRunInvalidArgs(t *testing.T) {
	err := run([]string{"--source", "file1.go", "--package", "pkg1"})
	if err == nil {
		t.Errorf("Expected error for conflicting flags")
	}

	expectedError := "--source and --package flags cannot be used together"
	if !strings.Contains(err.Error(), expectedError) {
		t.Errorf("Expected error to contain %q, got %q", expectedError, err.Error())
	}
}

func TestRunNoConfig(t *testing.T) {
	// Create a temporary directory without oak.yaml
	tempDir := t.TempDir()

	// Change to temp directory
	oldDir, _ := os.Getwd()
	os.Chdir(tempDir)
	defer os.Chdir(oldDir)

	err := run([]string{})
	if err == nil {
		t.Errorf("Expected error when oak.yaml is not found")
	}

	expectedError := "oak.yaml configuration file not found"
	if !strings.Contains(err.Error(), expectedError) {
		t.Errorf("Expected error to contain %q, got %q", expectedError, err.Error())
	}
}

func TestGroupStructsByPackage(t *testing.T) {
	structs := []parser.StructInfo{
		{Name: "User", PackageName: "main"},
		{Name: "Product", PackageName: "main"},
		{Name: "Order", PackageName: "orders"},
		{Name: "Item", PackageName: "orders"},
	}

	groups := groupStructsByPackage(structs)

	if len(groups) != 2 {
		t.Errorf("Expected 2 groups, got %d", len(groups))
	}

	if len(groups["main"]) != 2 {
		t.Errorf("Expected 2 structs in main package, got %d", len(groups["main"]))
	}

	if len(groups["orders"]) != 2 {
		t.Errorf("Expected 2 structs in orders package, got %d", len(groups["orders"]))
	}

	// Check struct names
	mainStructs := groups["main"]
	if mainStructs[0].Name != "User" || mainStructs[1].Name != "Product" {
		t.Errorf("Unexpected structs in main package: %v", mainStructs)
	}
}

// Integration test that creates a complete scenario
func TestIntegrationEndToEnd(t *testing.T) {
	// Create temporary directory structure
	tempDir := t.TempDir()

	// Create oak.yaml
	configContent := `packages:
  - ./testpkg
redactKeys:
  - password
redactMessage: "[REDACTED]"`

	err := os.WriteFile(filepath.Join(tempDir, "oak.yaml"), []byte(configContent), 0644)
	if err != nil {
		t.Fatalf("Failed to create oak.yaml: %v", err)
	}

	// Create test package directory
	pkgDir := filepath.Join(tempDir, "testpkg")
	err = os.MkdirAll(pkgDir, 0755)
	if err != nil {
		t.Fatalf("Failed to create package directory: %v", err)
	}

	// Create test Go file with struct
	goFileContent := `package testpkg

//go:generate oak
type User struct {
	ID       int
	Name     string
	Password string
	Notes    string ` + "`log:\"-\"`" + `
}`

	goFilePath := filepath.Join(pkgDir, "user.go")
	err = os.WriteFile(goFilePath, []byte(goFileContent), 0644)
	if err != nil {
		t.Fatalf("Failed to create Go file: %v", err)
	}

	// Change to temp directory
	oldDir, _ := os.Getwd()
	os.Chdir(tempDir)
	defer os.Chdir(oldDir)

	// Run oak
	err = run([]string{})
	if err != nil {
		t.Fatalf("Oak run failed: %v", err)
	}

	// Check that generated file exists
	generatedFile := filepath.Join(pkgDir, "testpkg_logvalue.go")
	if _, err := os.Stat(generatedFile); os.IsNotExist(err) {
		t.Errorf("Generated file does not exist: %s", generatedFile)
	}

	// Check generated file content
	content, err := os.ReadFile(generatedFile)
	if err != nil {
		t.Fatalf("Failed to read generated file: %v", err)
	}

	contentStr := string(content)

	// Check for expected elements
	expectedElements := []string{
		"// Code generated by oak. DO NOT EDIT.",
		"package testpkg",
		"import \"log/slog\"",
		"func (u User) LogValue() slog.Value",
		"slog.GroupValue(",
		"slog.Int64(\"ID\", int64(u.ID))",
		"slog.String(\"Name\", u.Name)",
		"slog.String(\"Password\", \"[REDACTED]\")",
	}

	for _, expected := range expectedElements {
		if !strings.Contains(contentStr, expected) {
			t.Errorf("Generated file missing expected element: %s", expected)
		}
	}

	// Check that Notes field is not included (log:"-")
	if strings.Contains(contentStr, "Notes") {
		t.Errorf("Generated file should not contain Notes field (marked with log:\"-\")")
	}
}
